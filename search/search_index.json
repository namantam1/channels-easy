{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Channels Easy A thin wrapper around channel consumers to make things EASY Note : This library currently support only text data which is JSON serializable. What problem does this library solve? This library simplifies two tasks for now 1. Parse incoming text data as JSON and vice versa. 2. Generate event on the basis of type passed from client side. Installation To get the latest stable release from PyPi pip install channels-easy To get the latest commit from GitHub pip install -e git+git://github.com/namantam1/channels-easy.git#egg=channels-easy As channels-easy is a thin wrapper around channels so channels must be in your INSTALLED_APPS in settings.py . INSTALLED_APPS = ( ..., 'channels', ) Example All the naming convention used to implement this library is inspired from socket.io to make server implementation simple. Get full example project here . Server side # consumers.py from channels_easy.generic import AsyncWebsocketConsumer class NewConsumer(AsyncWebsocketConsumer): async def connect(self): # join room on connect await self.join(\"room1\") await self.accept() async def disconnect(self, close_code): # Leave room on disconnect await self.leave(\"room1\") async def on_message(self, data): print(\"message from client\", data) # output: # message from client {'text': 'hello'} await self.emit(\"message\", \"room1\", {\"message\": \"hello from server\"}) Client side // client.js const socket = new WebSocket(\"ws://localhost:8000/ws/test/\"); socket.onmessage = function ({ data }) { const parsed_data = JSON.parse(data); console.log(parsed_data); // output: // { // data: {message: 'hello from server'} // type: \"message\" // } }; socket.onopen = () => { console.log(\"websocket connected...\"); // send message from client after connected // send with type `message` to receive from subscribed // `on_message` event on server side socket.send( JSON.stringify({ type: \"message\", data: { text: \"hello\", }, }) ); }; API Usage Subscribing to events We can simply subscribe to a message type as def on_<type>(self, data): ... pass so if client send data as { \"type\": \"message\", \"data\": \"Hello!\" } We can subscribe to message event as def on_message(self, data): ... pass Emitting Message We can emit message to client using same schema that we used above def on_message(self, data): ... # some code here ... self.emit( \"message\", # type [\"room1\"], # room list or string {\"text\": \"hello\"} # message dict | str | int | list ) Check all APIs here . Contribute If you want to contribute to this project, please perform the following steps # Fork this repository # Clone your fork poetry install git checkout -b feature_branch master # Implement your feature and tests git add . && git commit git push -u origin feature_branch # Send us a pull request for your feature branch In order to run the tests, simply execute poetry run pytest . This will run test created inside test directory.","title":"Home"},{"location":"#channels-easy","text":"A thin wrapper around channel consumers to make things EASY Note : This library currently support only text data which is JSON serializable. What problem does this library solve? This library simplifies two tasks for now 1. Parse incoming text data as JSON and vice versa. 2. Generate event on the basis of type passed from client side.","title":"Channels Easy "},{"location":"#installation","text":"To get the latest stable release from PyPi pip install channels-easy To get the latest commit from GitHub pip install -e git+git://github.com/namantam1/channels-easy.git#egg=channels-easy As channels-easy is a thin wrapper around channels so channels must be in your INSTALLED_APPS in settings.py . INSTALLED_APPS = ( ..., 'channels', )","title":"Installation"},{"location":"#example","text":"All the naming convention used to implement this library is inspired from socket.io to make server implementation simple. Get full example project here . Server side # consumers.py from channels_easy.generic import AsyncWebsocketConsumer class NewConsumer(AsyncWebsocketConsumer): async def connect(self): # join room on connect await self.join(\"room1\") await self.accept() async def disconnect(self, close_code): # Leave room on disconnect await self.leave(\"room1\") async def on_message(self, data): print(\"message from client\", data) # output: # message from client {'text': 'hello'} await self.emit(\"message\", \"room1\", {\"message\": \"hello from server\"}) Client side // client.js const socket = new WebSocket(\"ws://localhost:8000/ws/test/\"); socket.onmessage = function ({ data }) { const parsed_data = JSON.parse(data); console.log(parsed_data); // output: // { // data: {message: 'hello from server'} // type: \"message\" // } }; socket.onopen = () => { console.log(\"websocket connected...\"); // send message from client after connected // send with type `message` to receive from subscribed // `on_message` event on server side socket.send( JSON.stringify({ type: \"message\", data: { text: \"hello\", }, }) ); };","title":"Example"},{"location":"#api-usage","text":"Subscribing to events We can simply subscribe to a message type as def on_<type>(self, data): ... pass so if client send data as { \"type\": \"message\", \"data\": \"Hello!\" } We can subscribe to message event as def on_message(self, data): ... pass Emitting Message We can emit message to client using same schema that we used above def on_message(self, data): ... # some code here ... self.emit( \"message\", # type [\"room1\"], # room list or string {\"text\": \"hello\"} # message dict | str | int | list ) Check all APIs here .","title":"API Usage"},{"location":"#contribute","text":"If you want to contribute to this project, please perform the following steps # Fork this repository # Clone your fork poetry install git checkout -b feature_branch master # Implement your feature and tests git add . && git commit git push -u origin feature_branch # Send us a pull request for your feature branch In order to run the tests, simply execute poetry run pytest . This will run test created inside test directory.","title":"Contribute"},{"location":"apis/","text":"API Reference channels_easy.generic.AsyncWebsocketConsumer ( AsyncWebsocketConsumer ) close_with_error(self, error_data, code=None) async Close socket after emitting error message Parameters: error_data ( Any ) \u2013 Any json serializable data code ( int ) \u2013 Close code pass to close emit(self, typ, to, data) async Send message to given rooms Parameters: typ ( str ) \u2013 message type to ( Union[str, Iterable] ) \u2013 List of rooms or a single room data ( Any ) \u2013 data which is json serializable emit_error(self, data) async Emit message with error type and data Parameters: data ( Any ) \u2013 Any json serializable value join(self, room) async Join room with passed name Parameters: room ( Union[str, Iterable] ) \u2013 List of room or a single room leave(self, room) async Leave room with passed name Parameters: room ( Union[str, Iterable] ) \u2013 List of room or a single room","title":"API Reference"},{"location":"apis/#api-reference","text":"","title":"API Reference"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer","text":"","title":"AsyncWebsocketConsumer"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.close_with_error","text":"Close socket after emitting error message Parameters: error_data ( Any ) \u2013 Any json serializable data code ( int ) \u2013 Close code pass to close","title":"close_with_error()"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.emit","text":"Send message to given rooms Parameters: typ ( str ) \u2013 message type to ( Union[str, Iterable] ) \u2013 List of rooms or a single room data ( Any ) \u2013 data which is json serializable","title":"emit()"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.emit_error","text":"Emit message with error type and data Parameters: data ( Any ) \u2013 Any json serializable value","title":"emit_error()"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.join","text":"Join room with passed name Parameters: room ( Union[str, Iterable] ) \u2013 List of room or a single room","title":"join()"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.leave","text":"Leave room with passed name Parameters: room ( Union[str, Iterable] ) \u2013 List of room or a single room","title":"leave()"}]}