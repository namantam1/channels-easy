{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Channels Easy A thin wrapper around channel consumers to make things EASY Note : This library currently support only text data which is JSON serializable. What problem does this library solve? This library simplifies two tasks for now Parse incoming text data as JSON and vice versa. Generate event on the basis of type passed from client side. Table of Contents Installation Example API Usage Contribute Installation To get the latest stable release from PyPi pip install channels-easy As channels-easy is a thin wrapper around channels so channels must be in your INSTALLED_APPS in settings.py . INSTALLED_APPS = ( ..., 'channels' , ) Example All the naming convention used to implement this library is inspired from socket.io to make server implementation simple. Get full example project here . Server side # consumers.py from channels_easy.generic import AsyncWebsocketConsumer class NewConsumer ( AsyncWebsocketConsumer ): async def connect ( self ): # join room on connect await self . join ( \"room1\" ) await self . accept () async def disconnect ( self , close_code ): # Leave room on disconnect await self . leave ( \"room1\" ) async def on_message ( self , data ): print ( \"message from client\" , data ) # output: # message from client {'text': 'hello'} await self . emit ( \"message\" , { \"message\" : \"hello from server\" }, \"room1\" ) Client side // client.js const socket = new WebSocket ( \"ws://localhost:8000/ws/test/\" ); socket . onmessage = function ({ data }) { const parsed_data = JSON . parse ( data ); console . log ( parsed_data ); // output: // { // data: {message: 'hello from server'} // type: \"message\" // } }; socket . onopen = () => { console . log ( \"websocket connected...\" ); // send message from client after connected // send with type `message` to receive from subscribed // `on_message` event on server side socket . send ( JSON . stringify ({ type : \"message\" , data : { text : \"hello\" , }, }) ); }; API Usage Subscribing to events We can simply subscribe to a message type as def on_ < type > ( self , data ): ... pass so if client send data as { \"type\" : \"message\" , \"data\" : \"Hello!\" } We can subscribe to message event as def on_message ( self , data ): ... pass Emitting Message We can emit message to client using same schema that we used above def on_message ( self , data ): ... # some code here ... self . emit ( \"message\" , # type { \"text\" : \"hello\" }, # message dict | str | int | list [ \"room1\" ], # room list or string ) Check all APIs here . Contribute If you want to contribute to this project, please perform the following steps # Fork this repository # Clone your fork poetry install git checkout -b feature_branch master # Implement your feature and tests git add . && git commit git push -u origin feature_branch # Send us a pull request for your feature branch In order to run the tests, simply execute poetry run pytest . This will run test created inside test directory.","title":"Home"},{"location":"#channels-easy","text":"A thin wrapper around channel consumers to make things EASY Note : This library currently support only text data which is JSON serializable. What problem does this library solve? This library simplifies two tasks for now Parse incoming text data as JSON and vice versa. Generate event on the basis of type passed from client side. Table of Contents Installation Example API Usage Contribute","title":"Channels Easy "},{"location":"#installation","text":"To get the latest stable release from PyPi pip install channels-easy As channels-easy is a thin wrapper around channels so channels must be in your INSTALLED_APPS in settings.py . INSTALLED_APPS = ( ..., 'channels' , )","title":"Installation"},{"location":"#example","text":"All the naming convention used to implement this library is inspired from socket.io to make server implementation simple. Get full example project here . Server side # consumers.py from channels_easy.generic import AsyncWebsocketConsumer class NewConsumer ( AsyncWebsocketConsumer ): async def connect ( self ): # join room on connect await self . join ( \"room1\" ) await self . accept () async def disconnect ( self , close_code ): # Leave room on disconnect await self . leave ( \"room1\" ) async def on_message ( self , data ): print ( \"message from client\" , data ) # output: # message from client {'text': 'hello'} await self . emit ( \"message\" , { \"message\" : \"hello from server\" }, \"room1\" ) Client side // client.js const socket = new WebSocket ( \"ws://localhost:8000/ws/test/\" ); socket . onmessage = function ({ data }) { const parsed_data = JSON . parse ( data ); console . log ( parsed_data ); // output: // { // data: {message: 'hello from server'} // type: \"message\" // } }; socket . onopen = () => { console . log ( \"websocket connected...\" ); // send message from client after connected // send with type `message` to receive from subscribed // `on_message` event on server side socket . send ( JSON . stringify ({ type : \"message\" , data : { text : \"hello\" , }, }) ); };","title":"Example"},{"location":"#api-usage","text":"Subscribing to events We can simply subscribe to a message type as def on_ < type > ( self , data ): ... pass so if client send data as { \"type\" : \"message\" , \"data\" : \"Hello!\" } We can subscribe to message event as def on_message ( self , data ): ... pass Emitting Message We can emit message to client using same schema that we used above def on_message ( self , data ): ... # some code here ... self . emit ( \"message\" , # type { \"text\" : \"hello\" }, # message dict | str | int | list [ \"room1\" ], # room list or string ) Check all APIs here .","title":"API Usage"},{"location":"#contribute","text":"If you want to contribute to this project, please perform the following steps # Fork this repository # Clone your fork poetry install git checkout -b feature_branch master # Implement your feature and tests git add . && git commit git push -u origin feature_branch # Send us a pull request for your feature branch In order to run the tests, simply execute poetry run pytest . This will run test created inside test directory.","title":"Contribute"},{"location":"apis/","text":"API Reference channels_easy.generic.AsyncWebsocketConsumer ( AsyncWebsocketConsumer ) emit ( self , typ , data , to = None , close = None ) async Send message to given rooms Parameters: Name Type Description Default typ str message type required data Any data which is json serializable required to Union[str, int, Iterable] List of rooms or a single room None close Union[int, boolean] Boolean or error code, If passed close socket after emitting message None Note : If to is not passed, emit message to self user emit_error ( self , data , close = None ) async Emit message with error type and data Parameters: Name Type Description Default data Any Any json serializable value required close Union[int, boolean] Boolean or error code. If passed close socket after emitting error None join ( self , room ) async Join room with passed name Parameters: Name Type Description Default room Union[str, Iterable] List of room or a single room required leave ( self , room ) async Leave room with passed name Parameters: Name Type Description Default room Union[str, Iterable] List of room or a single room required","title":"API Reference"},{"location":"apis/#api-reference","text":"","title":"API Reference"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer","text":"","title":"AsyncWebsocketConsumer"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.emit","text":"Send message to given rooms Parameters: Name Type Description Default typ str message type required data Any data which is json serializable required to Union[str, int, Iterable] List of rooms or a single room None close Union[int, boolean] Boolean or error code, If passed close socket after emitting message None Note : If to is not passed, emit message to self user","title":"emit()"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.emit_error","text":"Emit message with error type and data Parameters: Name Type Description Default data Any Any json serializable value required close Union[int, boolean] Boolean or error code. If passed close socket after emitting error None","title":"emit_error()"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.join","text":"Join room with passed name Parameters: Name Type Description Default room Union[str, Iterable] List of room or a single room required","title":"join()"},{"location":"apis/#channels_easy.generic.AsyncWebsocketConsumer.leave","text":"Leave room with passed name Parameters: Name Type Description Default room Union[str, Iterable] List of room or a single room required","title":"leave()"}]}